# 1.创建线程（池）时要指定有意义的名称，以便问题追溯；自定义命名线程工厂

# 2.不要new线程，要用线程池
- 1.线程的创建和销毁是有系统开销的，会把系统资源耗尽

- 2.线程池好处：

（1）执行大量异步任务时线程池能够复用线程，提供较好地性能；

（2）线程池提供一种资源限制和管理的手段，比如限制线程的个数、动态新增线程等，每个ThreadPoolExecutor
也保留了一些基本的统计数据，比如：

    getActiveCount当前激活的线程个数（正在执行任务的线程）

    getCompleteTaskCout已经完成的任务个数

    getTaskCount所有的任务个数，包括已经完成的、正在执行的、在队列里缓存的

# 3.不允许使用工具类Executor创建线程池，而是通过手动构造ThreadPoolExecutor来创建
- 如：
```
return new ThreadPoolExecutor(nThreads,nThreads,0L,
                TimeUnit.MILLISECONDS,new LinkedBlockingDeque<Runnable>(),threadFactory);
```

# 4.SimpleFormateDate
- 1.SimpleDateFormat是线程不安全的，主要是其中存在共享变量，并且没有在访问共享变量前进行适当的同步处理

- 2.解决线程安全的方法：

（1）定义工具类，每次使用时返回一个SimpleDateFormat的实例，这样可以保证每个实例使用自己的Calendar实例，
但是每次使用都需要new一个对象，并且使用后由于没有其他引用，就会需要被回收，开销会很大

（2）多线程中可以使用synchronized进行同步


# 5.Synchronized
- 高并发时，同步调用应该考虑锁的性能。能用无锁，就不要用锁，一定要用锁的时候，加锁粒度尽量小。

- 为避免多线程访问共享资源时的并发问题，一般需要在访问共享资源前进行适当同步，比如在处理共享
资源前加独占锁，比如在处理共享资源前加独占锁，再处理资源，然后释放锁。

(1)进入synchronized块前会清空锁块内本地内存中将会使用到的共享变量，然后调用getVal方法从主内存
中获取变量的值，退出synchronized块会把修改刷新到主内存，从而保证了共享变量的可见性。
(2)synchronized块加的是独占锁，这导致线程只能有一个线程获取锁调用getVal方法获取当前变量的值，
而getVal方法本身不会修改val的值，大大降低了读取的并发性。

(1)变量val不依赖原来的值，使用无锁的volatile可以解决内存不可见问题
(2)volatile只能保证内存可见性，不能保证原子性，例如计数器不能使用volatile

(1)synchronized是独占锁，导致同时调用getVal方法读取val的值的线程竞争独占锁，
降低了并发度，可以适当降低锁的范围，实现读写分离

(1)使用读写分离，多个线程可以同时获取读取锁然后获取val，增加了读取的并发度
(2)关于计数器，JUC（Java Util Concurrence）包提供了AtomicInteger、AtomicLong等类
(3)如果担心在高并发下，大量线程在进行CAS失败后进行自旋重试，LongAdder是更好的选择

# 6.悲观锁与乐观锁
-
并发修改同一条记录时需要加锁以避免丢失更新；
锁可以是应用层的，可以是缓存层的，也可以是数据库层的；
数据库层的两种方式：悲观锁、乐观锁。

-
如果每次访问冲突的概率小于20%，建议使用乐观锁，这是因为乐观锁本身不需要对行记录加锁，
并发性能较好，另外使用乐观锁时重试次数不小于3次。如果每次访问冲突概率比较大，那么使
用乐观锁会导致重试次数较高，并且等达到重试次数后，也不一定更新OK，所以这时候使用悲观锁。

-
对于应用层，一般使用分布式锁来做同步，缓存上可以使用Redis的CAS操作来做同步。

-
悲观锁指对数据被外界修改保持保守态度，认为数据很容易被其他线程修改，所以在数据处理之前先对数据进行加锁，
并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，数据库中实现是对
数据记录操作前给记录加排他锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。
如果获取锁成功，则对记录进行操作，事务提交成功后释放排他锁。

-
乐观锁是相对于悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排它锁，
而是在数据提交更新的时候，才会正式对数据的冲突与否进行检测。具体来说，是根据update返回的行
数让用户决定如何去做。

# 7.Timer
- Timer内部当执行任务的过程中抛出了除InterruptedException之外的异常后，唯一的消费线程就会因为
抛出异常而终止，队列里面执行的其他任务就会被终止。

- Timer下启动多个任务，只要其中一个任务抛出异常，其他任务会自动终止，ScheduledExecutorService
不会有这个风险。

# 8.CountDownLatch
- 使用CountDownLatch，要注意countDown()方法要在finally块内执行，避免抛异常后得不到执行。

# 9.ThreadLocal
-
（1）ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是说如果你创建一个ThreadLocal变量，
那么访问这个变量的每一个线程都会有这个变量的一个本地拷贝，从而避免了线程安全问题。
（2）ThreadLocal无法解决共享变量更新的问题，并建议使用static修饰。
（3）thread1和thread2分别管理自己的本地变量，彼此是访问不了对方的变量的。
（4）每个线程中保存的是自己本地内存中的ThreadLocal变量值，多个线程访问的根本就不是共享变量。
（5）如果没有使用static修饰，则每创建一个TestThreadLocal实例，内部都会创建一个ThreadLocal实例，
如果使用static修饰，则所有的TestThreadLocal实例共享同一个ThreadLocal实例。